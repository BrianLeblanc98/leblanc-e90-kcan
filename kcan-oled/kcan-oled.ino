#include <Serial_CAN_Module.h>
#include <SoftwareSerial.h>
#include <U8g2lib.h>
#include <U8x8lib.h>
#include <Wire.h>
#include <Adafruit_SSD1306.h>

/*
   OBD2 can requires 120 ohm on the receiver
   KCAN requires the 120 ohm to be NOT there
*/

// E90 picture
const unsigned char E90[] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0xff, 0xff, 0xff, 0xff, 0xe3, 0x80, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0x00, 0x1c, 0x00, 0x00, 0xfc, 0xe0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xe0, 0x00, 0x1c, 0x00, 0x00, 0xc3, 0x3c, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x8f, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x43, 0xc0, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x20, 0x78, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x20, 0x1f, 0xf0, 0x00,
  0x00, 0x00, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x20, 0x03, 0xff, 0x80,
  0x00, 0x07, 0x80, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x40, 0x00, 0x01, 0xc0,
  0x00, 0x1e, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc0, 0x80, 0x00, 0x07, 0xc0,
  0x00, 0x78, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0xc1, 0x00, 0x00, 0x0e, 0xc0,
  0x03, 0xc0, 0x00, 0x00, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x0c, 0xc0,
  0x07, 0xe0, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x04, 0x00, 0x00, 0x0c, 0x60,
  0x08, 0x20, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x08, 0x00, 0x00, 0x0e, 0x60,
  0x10, 0x60, 0x00, 0x00, 0x0c, 0x00, 0x00, 0x07, 0x88, 0x00, 0x0f, 0x10, 0x00, 0x00, 0x07, 0xf0,
  0x20, 0xe0, 0x7f, 0x80, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x20, 0xff, 0x00, 0x00, 0xf0,
  0x23, 0xc1, 0x80, 0x60, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x43, 0x00, 0xc0, 0x00, 0x10,
  0x3f, 0x03, 0x00, 0x30, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x86, 0x00, 0x60, 0x00, 0x30,
  0x20, 0x06, 0x00, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x0c, 0x00, 0x30, 0x00, 0x30,
  0x20, 0x0c, 0x00, 0x0c, 0x04, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x18, 0x00, 0x18, 0x00, 0x30,
  0x20, 0x0c, 0x00, 0x0c, 0x06, 0x00, 0x00, 0x00, 0x08, 0x00, 0x04, 0x18, 0x00, 0x18, 0x00, 0x3c,
  0x20, 0x14, 0x00, 0x0a, 0x03, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x28, 0x00, 0x14, 0x00, 0x24,
  0x30, 0x14, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x00, 0x14, 0x00, 0x7c,
  0x3c, 0x12, 0x00, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x00, 0x24, 0x00, 0x60,
  0x0f, 0xf3, 0x00, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe6, 0x00, 0x67, 0xff, 0xc0,
  0x00, 0x01, 0x80, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0xc0, 0x00, 0x00,
  0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x81, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00
};

#define can_tx  2
#define can_rx  3

#define screen_width 128 //OLED display width in pixels
#define screen_height 32 //OLED display height in pixels

Serial_CAN can;
Adafruit_SSD1306 display(screen_width, screen_height);

void setup() {
  Serial.begin(9600);

  Serial.println("can begin");
  can.begin(can_tx, can_rx, 38400);

  Serial.println("display begin");
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.clearDisplay();
  display.display();
}

bool firstLoop = true;

unsigned long rxID = 0;
unsigned char rxBuf[8];

int coolantTemp, oilTemp, rpm = 0;
float engineNM = 0.0f;
bool newData;

byte page = 0;
byte NUM_PAGES = 2;
int voipButtonVal = 0;
int telephoneButtonVal = 0;

bool hasDrawnCarPicture = false;

void loop() {
  if (firstLoop) {
    Serial.println("loop begin");
    firstLoop = false;
  }

  // TODO: actually setup mask/filters in the setup function
  newData = false;
  if (can.recv(&rxID, rxBuf)) {
    if (rxID == 0x1D6) { // STEERING WHEEL BUTTONS
      if (rxBuf[0] == 0xC0) { // VOIP button pressed
        if (rxBuf[1] == 0x01) {
          voipButtonVal = 1;
        } else {
          voipButtonVal = 0;
        }
      } else if (rxBuf[0] == 0xC1) { // TELEPHONE button pressed
        if (rxBuf[1] == 0x00) {
          telephoneButtonVal = 1;
        } else {
          telephoneButtonVal = 0;
        }
      } else { // EVERY OTHER BUTTON
      }
    } else if (rxID == 0x130) { // IGNITION
      // printIdAndBuf(rxID, rxBuf);
    } else if (rxID == 0x0AA) { // RPM
      int prevRpm = rpm;
      getRpm(rxBuf, &rpm);
      if (prevRpm != rpm) {
        newData = true;
      }
    } else if (rxID == 0x1D0) { // Coolant/Oil temp
      int prevCoolantTemp = coolantTemp;
      int prevOilTemp = oilTemp;
      getCoolantAndOilTemp(rxBuf, &coolantTemp, &oilTemp);
      if (prevCoolantTemp != coolantTemp || prevOilTemp != oilTemp) {
        newData = true;
      }
    } else if (rxID == 0x2CA) { // Outside temp
      // Serial.println((rxBuf[0] - 80) / 2);
    } else if (rxID == 0x0A8) { // TORQUE
      // (byte2*256)+byte1 / 32 = Torque
      engineNM = ( (rxBuf[1] * 256) + rxBuf[0] ) / 32;
      float hp = (rpm * engineNM) / 9550;
      if (hp > 0) {
        Serial.println(hp);
      }
      
    } else {
      // printIdAndBuf(rxID, rxBuf);
    }
  }

  getPage();
  if (page == 0 && !hasDrawnCarPicture) {
    displayCarPicture();
    hasDrawnCarPicture = true;
  } else if (page == 1) {
    hasDrawnCarPicture = false;
    if (newData) {
      displayCoolantRPMOil(coolantTemp, rpm, oilTemp);
    }
  }


}

/*
   GET DATA FUNCTIONS
*/
void getCoolantAndOilTemp(unsigned char* rxBuf, int* coolantTemp, int* oilTemp) {
  *coolantTemp = rxBuf[0] - 48;
  *oilTemp = rxBuf[1] - 48;
}

void getRpm(unsigned char* rxBuf, int* rpm) {
  //      Serial.print("rpm: ");
  //      Serial.println();
  *rpm = ((rxBuf[5] * 256) + rxBuf[4]) / 4;
}


/*
   DISPLAY TO OLED FUNCTIONS
*/
void displayCarPicture() {
  display.clearDisplay();
  display.drawBitmap(0, 0, E90, 128, 64, WHITE);
  display.display();
}

void displayCoolantRPMOil(int coolantTemp, int rpm, int oilTemp) {
  display.clearDisplay();
  display.setTextSize(1);
  display.setTextColor(SSD1306_WHITE);

  // Water temp reading
  display.setCursor(5, 0);
  display.print("WATER");

  display.setCursor(8, 10);
  display.print("TEMP");

  // Oil temp reading
  display.setCursor(102, 0);
  display.print("OIL");

  display.setCursor(100, 10);
  display.print("TEMP");

  // RPM reading
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);

  display.setCursor(46, 0);
  display.print("RPM");

  // TEMPERATURE VARIABLES
  display.setTextSize(2);
  display.setTextColor(SSD1306_WHITE);
  display.setCursor(0, 18);
  display.print(coolantTemp);
  display.setCursor(40, 18);
  display.print(rpm);
  display.setCursor(92, 18);
  display.print(oilTemp);

  display.display();
}

/*
   HELPER FUNCTIONS
*/

int prevVoidButtonVal = 0;
bool getPage() {
  int prevPage = page;
  if (voipButtonVal && !prevVoidButtonVal) {
    page++;
    prevVoidButtonVal = voipButtonVal;
  } else if (!voipButtonVal && prevVoidButtonVal) {
    prevVoidButtonVal = voipButtonVal;
  }

  if (page >= NUM_PAGES) {
    page = 0;
  }

  return prevPage == page;
}


/*
   DEBUG FUNCTIONS
*/
void printIdAndBuf(unsigned long rxID, unsigned char* rxBuf) {
  Serial.print("get data from id 0x");
  Serial.print(rxID, HEX);
  Serial.print(": ");
  for (int i = 0; i < 8; i++) {
    Serial.print("0x");
    if (rxBuf[i] < 0x10) { // If data byte is less than 0x10, add a leading zero
      Serial.print("0");
    }

    Serial.print(rxBuf[i], HEX);
    Serial.print(' ');
  }
  Serial.println();
}
